---
title: Response
slug: Web/API/Response
tags:
  - API
  - Experimental
  - Fetch
  - Fetch API
  - Interface
  - Reference
  - Response
  - 参考
translation_of: Web/API/Response
---
<p>{{APIRef("Fetch API")}}</p>

<p> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a> 的 <code>Response</code> 接口呈现了对一次请求的响应数据。</p>

<p>你可以使用 {{domxref("Response.Response()")}} 构造函数来创建一个 <code>Response</code> 对象，但通常更可能遇到的情况是，其他的 API 操作返回了一个 Response 对象。例如一个 service worker 的 {{domxref("Fetchevent.respondWith")}}，或者一个简单的 {{domxref("GlobalFetch.fetch()")}}。</p>

<h2 id="构造函数">构造函数</h2>

<dl>
 <dt>{{domxref("Response.Response","Response()")}}</dt>
 <dd>创建一个新的 <code>Response</code> 对象。</dd>
</dl>

<h2 id="属性">属性</h2>

<dl>
 <dt>{{domxref("Response.headers")}} {{readonlyinline}}</dt>
 <dd>包含此 Response 所关联的 {{domxref("Headers")}} 对象。</dd>
 <dt>{{domxref("Response.ok")}} {{readonlyinline}}</dt>
 <dd>包含了一个布尔值，标示该 Response 成功（HTTP 状态码的范围在 200-299）。</dd>
 <dt>{{domxref("Response.redirected")}} {{ReadOnlyInline}}</dt>
 <dd>表示该 Response 是否来自一个重定向，如果是的话，它的 URL 列表将会有多个条目。</dd>
 <dt>{{domxref("Response.status")}} {{readonlyinline}}</dt>
 <dd>包含 Response 的状态码（例如 <code>200</code> 表示成功）。</dd>
 <dt>{{domxref("Response.statusText")}} {{readonlyinline}}</dt>
 <dd>包含了与该 Response 状态码一致的状态信息（例如，OK 对应 <code>200</code>）。</dd>
 <dt>{{domxref("Response.type")}} {{readonlyinline}}</dt>
 <dd>包含 Response 的类型（例如，<code>basic</code>、<code>cors</code>）。</dd>
 <dt>{{domxref("Response.url")}} {{readonlyinline}}</dt>
 <dd>包含 Response 的 URL。</dd>
 <dt>{{domxref("Response.useFinalURL")}}</dt>
 <dd>包含了一个布尔值，来标示这是否是该 Response 的最终 URL。</dd>
</dl>

<p><code>Response</code> 实现了 {{domxref("Body")}} 接口，所以以下属性亦可用：</p>

<dl>
 <dt>{{domxref("Body.body")}} {{readonlyInline}}</dt>
 <dd>一个简单的 getter，用于暴露一个 {{domxref("ReadableStream")}} 类型的 body 内容。</dd>
 <dt>{{domxref("Body.bodyUsed")}} {{readonlyInline}}</dt>
 <dd>包含了一个{{domxref("Boolean", "布尔值")}}来标示该 Response 是否读取过 {{domxref("Body")}}。</dd>
</dl>

<h2 id="方法">方法</h2>

<dl>
 <dt>{{domxref("Response.clone()")}}</dt>
 <dd>创建一个 <code>Response</code> 对象的克隆。</dd>
 <dt>{{domxref("Response.error()")}}</dt>
 <dd>返回一个绑定了网络错误的新的 <code>Response</code> 对象。</dd>
 <dt>{{domxref("Response.redirect()")}}</dt>
 <dd>用另一个 URL 创建一个新的 <code>Response</code>。</dd>
</dl>

<p><code>Response</code> 实现了 {{domxref("Body")}} 接口，所以以下方法同样可用：</p>

<dl>
 <dt>{{domxref("Body.arrayBuffer()")}}</dt>
 <dd>读取 {{domxref("Response")}} 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 {{domxref("ArrayBuffer")}} 格式的 Promise 对象。</dd>
 <dt>{{domxref("Body.blob()")}}</dt>
 <dd>读取 {{domxref("Response")}} 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 {{domxref("Blob")}} 格式的 Promise 对象。</dd>
 <dt>{{domxref("Body.formData()")}}</dt>
 <dd>读取{{domxref("Response")}} 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 {{domxref("FormData")}} 格式的 Promise 对象。</dd>
 <dt>{{domxref("Body.json()")}}</dt>
 <dd>读取 {{domxref("Response")}} 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 {{domxref("JSON")}} 格式的 Promise 对象。</dd>
 <dt>{{domxref("Body.text()")}}</dt>
 <dd>读取 {{domxref("Response")}} 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 {{domxref("USVString")}} 格式的 Promise 对象。</dd>
</dl>

<h2 id="示例">示例</h2>

<p>在我们的<a href="https://github.com/mdn/fetch-examples/tree/gh-pages/basic-fetch">基础实例</a> (<a href="http://mdn.github.io/fetch-examples/basic-fetch/">点击运行</a>) 中 , 我们使用了一个简单的函数调用 , 调用了 <code>fetch()</code> 函数来获取一张图片并将其显示在 HTML 的 IMG 标签中 , <code>fetch()</code> 函数返回了一个 Promise，它使用与资源获取操作相关联的 Response 对象进行解析。你会注意到，由于我们正在请求一张图片，我们需要运行{{domxref("Body.blob")}}（{{domxref("Response")}} 实现了），以为响应提供正确的 MIME 类型。</p>

<pre class="brush: js">const image = document.querySelector('.my-image');
fetch('flowers.jpg').then(function(response) {
  return response.blob();
}).then(function(blob) {
  const objectURL = URL.createObjectURL(blob);
  image.src = objectURL;
});</pre>

<p>你也可以使用 {{domxref("Response.Response()")}} 这样的构造方法，来创建自定义的 <code>Response</code> 对象：</p>

<pre class="brush: js">const response = new Response();</pre>

<h2 id="规范">规范</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
   <th scope="col">Status</th>
   <th scope="col">Comment</th>
  </tr>
  <tr>
   <td>{{SpecName('Fetch','#response-class','Response')}}</td>
   <td>{{Spec2('Fetch')}}</td>
   <td>Initial definition</td>
  </tr>
 </tbody>
</table>

<h2 id="浏览器兼容性">浏览器兼容性</h2>



<p>{{Compat("api.Response")}}</p>

<h2 id="相关链接">相关链接</h2>

<ul>
 <li><a href="/en-US/docs/Web/API/ServiceWorker_API">ServiceWorker API</a></li>
 <li><a href="/en-US/docs/Web/HTTP/Access_control_CORS">HTTP access control (CORS)</a></li>
 <li><a href="/en-US/docs/Web/HTTP">HTTP</a></li>
</ul>
