---
title: TextDecoder
slug: Web/API/TextDecoder
tags:
  - API
  - DOM
  - 参考
  - 接口
  - 编码
translation_of: Web/API/TextDecoder
---
<div>{{APIRef("Encoding API")}}</div>

<p><code><strong>TextDecoder</strong></code> 接口表示一个文本解码器，一个解码器只支持一种特定文本编码，例如 <code>utf-8</code>、<code>iso-8859-2</code>、<code>koi8</code>、<code>cp1261</code>，<code>gbk</code> 等等。解码器将字节流作为输入，并提供代码点流作为输出。</p>

<h2 id="例子">例子</h2>

<h3 id="用类型化数组表示文本">用类型化数组表示文本</h3>

<p>本示例展示如何解码中文/日语字符<img alt="" src="https://mdn.mozillademos.org/files/16663/2019-05-21_191907.png" style="height: 32px; width: 41px;">，用五个不同的数组类型表示： {{jsxref("Uint8Array")}}, {{jsxref("Int8Array")}}, {{jsxref("Uint16Array")}}, {{jsxref("Int16Array")}}, {{jsxref("Int32Array")}}</p>

<pre class="brush: js; line-numbers language-js notranslate"><code class="language-js">let utf8decoder = new TextDecoder(); // default 'utf-8' or 'utf8'

let u8arr = new Uint8Array([240, 160, 174, 183]);
let i8arr = new Int8Array([-16, -96, -82, -73]);
let u16arr = new Uint16Array([41200, 47022]);
let i16arr = new Int16Array([-24336, -18514]);
let i32arr = new Int32Array([-1213292304]);

console.log(utf8decoder.decode(u8arr));
console.log(utf8decoder.decode(i8arr));
console.log(utf8decoder.decode(u16arr));
console.log(utf8decoder.decode(i16arr));
console.log(utf8decoder.decode(i32arr));</code></pre>

<h3 id="处理非UTF8文本">处理非UTF8文本</h3>

<p>在此示例中，我们对俄语文本“Привет，мир！”( "Hello, world.")进行解码。在我们的 {{domxref("TextDecoder/TextDecoder", "TextDecoder()")}} 构造函数中，我们指定Windows-1251字符编码，适用于西里尔字母。</p>

<pre class="brush: js; line-numbers language-js notranslate"><code class="language-js">let win1251decoder = new TextDecoder('windows-1251');
let bytes = new Uint8Array([207, 240, 232, 226, 229, 242, 44, 32, 236, 232, 240, 33]);
console.log(win1251decoder.decode(bytes)); // Привет, мир!</code></pre>

<h2 id="构造函数">构造函数</h2>

<dl>
 <dt>{{DOMxRef("TextDecoder.TextDecoder", "TextDecoder()")}}</dt>
 <dd>返回一个新构造的 <code>TextDecoder</code>，它使用参数中指定的解码方法生成代码点流。</dd>
</dl>

<h2 id="属性">属性</h2>

<p><em><code>TextDecoder</code> 接口不继承任何属性。</em></p>

<dl>
 <dt>{{DOMxRef("TextDecoder.prototype.encoding")}}{{ReadOnlyInline}}</dt>
 <dd>{{DOMxRef("DOMString")}}所包含的解码器的名称，表示<code>TextDecoder</code>所使用的解码方法的字符串。</dd>
 <dt>{{DOMxRef("TextDecoder.prototype.fatal")}}{{ReadOnlyInline}}</dt>
 <dd>布尔值，{{jsxref('Boolean')}}，是否显示致命错误。</dd>
 <dt>{{DOMxRef("TextDecoder.prototype.ignoreBOM")}} {{ReadOnlyInline}}</dt>
 <dd>布尔值，{{jsxref('Boolean')}}，是否忽略 BOM（byte order marker）标记。</dd>
</dl>

<h2 id="方法">方法</h2>

<dl>
</dl>

<p><em><em><code>TextDecoder</code> 接口不继承任何</em>方法</em>。</p>

<dl>
 <dt>{{DOMxRef("TextDecoder.prototype.decode()")}}</dt>
 <dd>返回一个{{DOMxRef("DOMString")}}，其中包含使用特定 <code>TextDecoder</code> 对象的方法解码的文本。</dd>
</dl>

<h2 id="规范">规范</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">规格</th>
   <th scope="col">状态</th>
   <th scope="col">评论</th>
  </tr>
  <tr>
   <td>{{SpecName("Encoding", "#interface-textdecoder", "TextDecoder")}}</td>
   <td>{{Spec2("Encoding")}}</td>
   <td>初始定义。</td>
  </tr>
 </tbody>
</table>

<h2 id="浏览器兼容性">浏览器兼容性</h2>

<div>


<p>{{Compat("api.TextDecoder")}}</p>
</div>

<h2 id="相关链接">相关链接</h2>

<ul>
 <li>{{DOMxRef("TextEncoder")}} 接口描述了逆操作。</li>
 <li><a href="/en-US/Add-ons/Code_snippets/StringView"><code>StringView</code></a> –基于类型数组的字符串的类似C的表示形式</li>
 <li>一个<a href="http://code.google.com/p/stringencoding/">垫片</a>，允许在不支持它的浏览器使用这个接口。</li>
 <li><code><a href="/en-US/docs/Components.utils.importGlobalProperties">Components.utils.importGlobalProperties</a></code></li>
 <li><a href="https://nodejs.org/api/util.html#util_class_util_textdecoder">Node.js支持从v11.0.0全局导出</a></li>
</ul>
