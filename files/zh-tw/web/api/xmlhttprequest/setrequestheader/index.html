---
title: XMLHttpRequest.setRequestHeader()
slug: Web/API/XMLHttpRequest/setRequestHeader
translation_of: Web/API/XMLHttpRequest/setRequestHeader
---
<div>{{APIRef('XMLHttpRequest')}}</div>

<p>{{domxref("XMLHttpRequest")}} 物件中的 <code><strong>setRequestHeader()</strong></code> 方法用來設定 HTTP 的表頭請求。當使用 <code>setRequestHeader()</code> 的時候，必須在 {{domxref("XMLHttpRequest.open", "open()")}} 之後呼叫，同時也必須在 {{domxref("XMLHttpRequest.send", "send()")}} 之前呼叫。如果這個方法被呼叫了許多次，且設定的表頭是一樣的，那所有設定的值會被合併成一個單一的表頭請求。</p>

<p>在第一次呼叫 <code>setRequestHeader()</code> 之後的每一次的呼叫，都會把給定的文字附加在已存在的表頭內容之後。</p>

<p>If no {{HTTPHeader("Accept")}} header has been set using this, an <code>Accept</code> header with the type <code>"*/*"</code> is sent with the request when {{domxref("XMLHttpRequest.send", "send()")}} is called.</p>

<p>基於安全的理由，有些表頭只有使用者代理器可以使用。這些表頭包含了： {{Glossary("Forbidden_header_name", "forbidden header names", 1)}}  和 {{Glossary("Forbidden_response_header_name", "forbidden response header names", 1)}}.</p>

<div class="note">
<p><strong>Note:</strong> For your custom fields, you may encounter a "<strong>not allowed by Access-Control-Allow-Headers in preflight response</strong>" exception when you send requests across domains. In this situation, you need to set up the {{HTTPHeader("Access-Control-Allow-Headers")}} in your response header at server side.</p>
</div>

<h2 id="語法">語法</h2>

<pre class="syntaxbox"><em>XMLHttpRequest</em>.setRequestHeader(<var>header</var>, <var>value</var>)
</pre>

<h3 id="參數">參數</h3>

<dl>
 <dt><code>header</code></dt>
 <dd>想要設定所屬值的表頭名稱。</dd>
 <dt><code>value</code></dt>
 <dd>用來設定表頭本身的值。</dd>
</dl>

<h3 id="回傳值">回傳值</h3>

<p>未定義。</p>

<h2 id="規範">規範</h2>

{{Specifications}}

<h2 id="瀏覽器相容性">瀏覽器相容性</h2>



<p>{{Compat("api.XMLHttpRequest.setRequestHeader")}}</p>

<h2 id="參見">參見</h2>

<ul>
 <li><a href="/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest">Using XMLHttpRequest</a></li>
 <li><a href="/en-US/docs/Web/API/XMLHttpRequest/HTML_in_XMLHttpRequest">HTML in XMLHttpRequest</a></li>
</ul>
